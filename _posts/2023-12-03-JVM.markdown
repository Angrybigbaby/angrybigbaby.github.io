---
layout:     post
title:      "关于JVM的一些随笔"
subtitle:   "随便写点"
date:       2023-12-03
author:     "Bigbaby"
catalog:    true
tags:
  - Java
  - JVM
---

> 最近对JVM做了一些浅尝辄止的优化。那么工作结束后顺便梳理下相关知识，聊以自娱。

## 什么是JVM

全称是Java Virtual Machine（Java虚拟机），核心作用是保证Java进程的跨平台性。

## 做了什么

JVM调优主要可分为堆内存调优与垃圾回收调优。

GC是Java的垃圾回收机制。作为Java的重要功能之一，主要用于自动管理内存，使开发人员不需要手动分配和释放内存。

因为GC负责监测内存中不再使用的对象，并将它们自动回收以释放内存资源。

这样可以减少内存泄漏和程序崩溃的风险，但同时也会引入一些性能开销。

因此首先要在配置中指定打印GC日志，指定GC日志文件数和GC日志文件大小上限，并打印TimeStamps和DateStamps。

在项目中我们采用Concurrent Mark Sweep（CMS）的垃圾收集器。<s>CMS在Java14已经被移除了，然而我们用的还是Java8</s>

作为垃圾收集器的一种，CMS垃圾收集器优点就是并发收集，低停顿。

CMS尽可能缩短了垃圾收集时用户线程的等待时间（Stop-The-World）。

缺点就是在并发阶段，占用了一部分线程而导致了程序变慢，降低了总的吞吐量。此外比较吃CPU。<s>然而我们CPU资源过剩</s>

结合项目实际情况，CMS垃圾回收器可以提升数据引接环节的逻辑执行效率，提升数据时效性，符合项目实际需求。

对于CMS垃圾回收器，配置CMSParallelRemarkEnabled（采用并行标记方式降低停顿，默认开启），UseCMSInitiatingOccupancyOnly（该参数启用后，参数CMSInitiatingOccupancyFraction才会生效。默认关闭），CMSInitiatingOccupancyFraction=70（该值代表老年代堆空间的使用率，默认值为98。当老年代使用率达到此值之后，并行收集器便开始进行垃圾收集）。

对于堆内存部分，主要在考虑对JVM内存作合理限制，保证进程不会因为正常运行时资源紧张而影响稳定性，但也要避免因为内存泄漏影响其他进程的稳定性。

于是指定最小堆内存与最大堆内存为4g（-Xmx4g -Xms4g），防止内存溢出影响生产环境其他组件。

打印内存溢出的jvm快照，并指定对应的快照路径。这样便于追溯发生OOM时的日志信息。

此外，开启参数UseFastAccessorMethods（原始类型的JAVA自带的快速优化，优化原始类型的getter方法的性能）

暂时就这么多。

> 可能有人会说这不是数据开发的活，一点没错。但作为数据开发要不要掌握这些东西，我的观点是最好掌握。以实时开发为例，Flink的底层是Java，虽然Flink采取独立自主管理内存的路线，但在实际调优过程中仍会涉及JVM的内存参数。
 
 ![image](https://github.com/user-attachments/assets/35831b96-f530-4486-96f9-c98a00930b60)
 
> 假如你的生产环境有1G的余量可以分配给FlinkJob，那么要如何分配这些内存才能达到优化效果的最大化？
> 所以我一直认为，后端技术是数据开发的基础，而数据开发技术又是数据分析的基础。先从打牢基础开始，然后逐渐提升技术深度，最后随着职业生涯的经历逐渐丰富，从而拓宽技术广度。这是我所看到的，最合理的发展思路。

